
Nebenläufigkeit
Wir haben die Nebenläufigkeit immer nach demselben Prinzip implementiert:
Für jede Funktionalität, die nebenläufig realisiert werden soll, gibt es eine eigene Klasse A. In dieser Klasse steht dann eine Unterklasse B, die das Interface Runnable implementiert. Zunächst muss ein Objekt der Klasse A erzeugt werden, auf welchem dann eine Methode ausgeführt wird. Durch jene Methode werden dann Instanzen von B (im Folgenden: Agenten) erstellt und an den ThreadPoolExecuter übergeben. Dieser hält eine feste Anzahl von Threads bereit, ordnet neue Agenten in eine Warteschlange ein und startet den vordersten Agenten, sobald ein Thread frei ist.
 Dann wird gewartet bis alle Agenten vollständig ausgeführt wurden und der ThreadPoolExecuter terminiert. So wird sichergestellt, dass der nächste Berechnungsschritt im Hauptprogramm erst ausgeführt wird, wenn der vorherige fertig ist. Die Kommunikation der Agenten läuft dann über von Java vorimplementierte threadsichere Klassen wie ConcurrentHashMap, die selbstimplementierte threadsichere Klasse Lts, oder es wird explizit gelockt.
Algorithmus allgemein
Es wird zunächst ein LTS berechnet, welches dieselben Zustände und Aktionen hat wie das eingegebene LTS E, in dem alle schwachen Transitionen von E als starke Transitionen existieren. Dies wird auch schwaches LTS genannt. Auf das schwache LTS wird dann im zweiten Schritt die gröbste starke Bisimulation bestimmt. Dann werden bisimulative Zustände zusammengefasst und redundante Transitionen gelöscht. Zuletzt wird noch bei Bedarf eine reflexive τ-Transition an den Startzustand hinzugefügt um ein LTS zu erhalten, das beobachtungskongruent zur Eingabe ist.
Berechnung der schwachen Transitionen
Die Berechnung der schwachen Transitionen wird in der Klasse WeakLtsCalculator nebenläufig realisiert. Zunächst wird eine Instanz dieser Klasse erzeugt, wobei weakLts als Lts initialisiert wird, welches nur den initialen Knoten  enthält. Darauf wird dann calculate ausgeführt. Zuerst werden die unsichtbaren (calculateInvisible) und dann die sichtbaren (calculateVisible) schwachen Transitionen berechnet, wobei beide Schritte jeweils nebenläufig implementiert sind.
In calculateInvisible wird zunächst ein InternalReachabilityChecker konstruiert und berechnet. Dabei werden nebenläufig für jeden Zustand über Tiefensuche alle Zustände bestimmt, die ausschließlich über τ-Transitionen erreichbar sind. Dies ist so implementiert, dass man nach Konstruktion für jeden Zustand in konstanter Zeit sowohl jene Zustandsmenge abrufen kann, als auch ebenfalls in konstanter Zeit für zwei Zustände ihre τ-Erreichbarkeit überprüfen kann. Dann werden für jeden Zustand nebenläufig mithilfe des InternalReachabilityCheckers alle ausgehenden τ-Transitionen in weakLts geschrieben.
Bei der Bestimmung der sichtbaren Transitionen werden für jeden Zustand s nebenläufig alle schwachen sichtbaren Transitionen zu weakLts hinzugefügt, die sich durch eine starke sichtbare Transition ausgehend von s begründen lassen. Folgendes wird für jede Aktion a durchgeführt: Es werden mithilfe der bereits vorhandenen τ-Transitionen alle Nachfolger Post(Post(s,a), τ) in weakLts und alle Vorgänger Pre(s, τ) bestimmt, miteinander und mit a zu einer Transition verknüpft, die zu weakLts hinzugefügt wird.
Entfernung redundanter Transitionen
Zuletzt müssen noch redundante Transitionen entfernt werden. Es wird zunächst das alte LTS bis auf die Transitionen geklont. Dann werden alle Transitionen, die nicht redundant sind hinzugefügt, wobei Redundanz nach den folgenden Kriterien überprüft wird:
Transition(s,τ,t) redundant ⇔ ∃ r ∈ Post(s,τ), t ≠ r ≠ s ∧ t ∈ Post(r,τ)
Transition(s,a,t) redundant ⇔
 (∃ t’ ∈ Post(s,a), t’ ≠ t ∧ t ∈ Post(t‘,τ)) ∨ (∃ s’ ∈ Post(s,τ), s’ ≠ s Λ t ∈ Post(s’,a))
Diese Kriterien leiten sich aus
∃s’,t’ s -τ-> s‘ -τ-> t‘ –τ-> t  ∧ (s‘≠ s ∨ t‘≠ t)
∃s’,t’ s -τ-> s‘ -a-> t‘ –τ-> t  ∧ (s‘≠ s ∨ t‘≠ t)
und der Tatsache, dass das übergebene LTS jede schwache Transition auch als starke Transition enthält, her.
